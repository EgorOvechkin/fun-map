#### Q1: Расскажите, чем, на ваш взгляд, отличается хорошее клиентское приложение от плохого с точки зрения
**пользователя:**
Пользователю хочется получить позитивный опыт от работы с приложением. Для этого важна стабильность. Приложение не должно внезапно закрываться, “крашиться”(при этом теряя данные). Так же важна безопасность и конфиденциальность данных пользователя. Немаловажным является время отклика, т.е. приложение должно быстро выполнять задачи пользователя, с минимальным временем ожидания. Интуитивный и красивый интерфейс также будет плюсом. И еще я бы отметил поддержку. Как часто будут выходить обновления, как быстро будут правиться баги и уязвимости, на сколько развито сообщество вокруг этого приложения(наличие форумов и пр.), как легко разработчик приложения идет на контакт, реагирует на обратную связь(ответы на отзывы в магазине приложения, мб даже наличие линии горячей поддержки), всё это, на мой взгляд, влияет на то каким будет пользовательский опыт.<br />
**менеджера проекта:**
Для менеджера важна масштабируемость и гибкость. Т.е. то, как приложение будет справляться с ростом нагрузки, как рост количества пользователей будет влиять на поддержку и то насколько дорого будет обходиться внедрение новых фич и правка багов отличает хорошее приложение от плохого. Сплоченность команды, наверняка, так же важна для менеджера(как и для других участников проекта).<br />
**дизайнера:**
Я думаю, что для дизайнера хорошее приложение должно быть удобным, функциональным и, соответственно, красивым. Дизайнер, наверняка, положительно оценит какие-либо новаторские решения в интерфейсе, если они не будут ухудшать пользовательский опыт. Если говорить о разработке этого приложения, то для дизайнера плюсами будут понятные требования, простор для фантазии, налаженный тех. процесс(наличие стайл гайдов и тд).<br />
**верстальщика:**
Наличие стайл гайдов, качественные макеты, с указанием размеров и всевозможных состояний элементов. Хорошее приложение должно быть адаптивным, те удобным и красивым на различных устройствах.<br />
**серверного программиста:**
Для бэкенд разработчика важна хорошо выстроенная архитектура и качественная кодовая база. Существующий код должен быть покрыт тестами и хорошо читаем. Плюсом будет также налаженный процесс деплоя и возможность масштабировать проект. Безопасность и сбалансированность нагрузки — качества хорошего приложения.<br />

#### Q2: Опишите основные особенности разработки крупных многостраничных сайтов, функциональность которых может меняться в процессе реализации и поддержки. Расскажите о своем опыте работы над подобными сайтами: какие подходы, инструменты и технологии вы применяли на практике, с какими проблемами сталкивались и как их решали.

Можно выделить следующие особенности(проблемы) крупных веб приложений:
- **Большой объем кода.**<br/>
Большой функционал подразумевает большую кодовую базу, которую надо организовать так, чтобы с ней было возможно комфортно работать
- **Дублирование функциональности.**<br/>
На разных страницах сайта(а иногда и в рамках одной) может использоваться один и тот же функционал. В общем случае, нужно, чтобы это был физически один и тот же код, а не несколько одинаковых копий. Так изменение общего функционала будет проще и надежней.
- **Расширение функциональности.**<br/>
Приложения, как правило, развиваются и существующий функционал необходимо расширять. Желательно, чтобы это происходило достаточно быстро и безболезненно.
- **Отладка. Отлов ошибок.**<br/>
В крупных приложениях порой возникают ошибки. Необходимо быстро находить и устранять их.
- **Распределение знаний. Изменение состава команды.**<br/>
В крупных приложениях много бизнес-логики. Не все члены команды могут быть погружены во все нюансы, но очень желательно, чтобы при необходимости любой мог быстро разобраться как работает та или иная часть приложения. Это касается и новых членов команды.

Решать эти проблемы помогает хорошо выстроенная архитектура и применение общих подходов к организации кода.
На своем первом проекте я работал над веб-приложением для управления задачами. Клиентская часть была написана на react/redux. Т.е. мы использовали компонентный подход с применением flux архитектуры. Весь интерфейс был разделен на компоненты, которые описывались в отдельных файлах, а работа с данными была вынесена в редьюсеры. Так, я - новичок в веб-разработке, придя на проект и изучив в общих чертах react и redux, смог уже немного ориентироваться в коде, благодаря общепринятым архитектурным подходам. В серверной части применялись микросервисы на node.js. Это архитектурное решение позволяло в рамках одной задачи работать с небольшим node приложением реализующим относительно простое CRUD api(в качестве бд использовали mongodb) и, следовательно, с небольшим объемом кода. Но микросервисы требуют дополнительного внимания: нужно наладить связь му ними(для этого использовались RabbitMQ и websocket для связи с клиентом) и затрудняют отлов ошибок.
Сейчас я работаю над приложением написанным на Rails. Часть приложения рендерится на сервере, многое с помощью гема active_admin(далее я буду называть эту часть админкой, хотя на самом деле на active admin мы реализуем црм систему и с  которой работают все пользователи, не только администраторы). Но есть 2 отдельные страницы, которые по сути являются Single Page Application. Там мы используем Backbone и Marionette.js.

 Если говорить про админку, то js для нее мы разбивали на модули. Для реализации того или иного функционала пишется отдельный модуль, который реализуется в виде самовызывающейся функции и кладется в глобальную переменную. Все модули оформлены однотипно и собираются с помощью assets pipeline. Есть инициализирующий модуль, который пробегается по глобальной переменной и инициализирует остальные. Проблемы такого подхода, на мой взгляд, в том, что мы засоряем глобальную область видимости и расходуем память. Помимо этого сборка чз ассеты использует минификатор который не понимает ES6. Мы решили обойти эти проблемы путем внедрения webpack. Сейчас проект на переходной стадии, старые модули по-прежнему собираются чз ассеты, новые — через вебпак. Новые модули не складываются в глобальную область видимости, а импортируются или инициализируются самостоятельно, если нужно. Webpack привнёс возможность использовать современный синтаксис и подключать библиотеки чз npm пакеты.

Что касается наших SPA тут мы используем архитектуру MV*(в backbone нет контроллера в явном виде, но есть роутер, выполняющий его функции, который изначально у нас не был внедрен). Сначала у нас была одна такая страница. Мы называем её планировщик. На ней сидят пользователи с определенной ролью и работают там с клиентами. Большая часть интерфейса реализована посредством вьюх и моделей. Но хранились эти компоненты(здесь я использую слово компоненты в широком смысле, как составные части системы, а не react components) в 2ух громоздких файлах(views.js и models.js). Все вью и модели также складывались в переменную, чтобы затем инициализироваться в корневом файле планировщика. Возникла необходимость создания страницы с похожим функционалом, для пользователей с другой ролью. Так я столкнулся с проблемой переиспользования. Большую часть вью и моделей из планировщика нужно было использовать на новой странице, добавив туда несколько новых. Для этого я создал общий неймспэйс для моделей и вьюх. Выносил их из общего файла в отдельные и добавлял немного универсальности для работы на двух страницах. В лейаутах на обоих страницах я добавил переменную moduleName для того чтобы идентифицировать страницу, если нужно. Так, после декомпозиции больших файлов и небольшого рефакторинга, я смог переиспользовать вью и модели планировщика для новой страницы. Стоит отметить чтo webpack также изменил подход к организации компонентов и на этих страницах. После его внедрения отпала необходимость хранить конструкторы в глобальной переменной, стало достаточным экспортировать их из файла и импортировать в нужное место для инициализации.

#### Q3: При разработке интерфейсов с использованием компонентной архитектуры часто используются термины Presentational Сomponents и Сontainer Сomponents. Что означают данные термины? Зачем нужно такое разделение, какие у него есть плюсы и минусы?

**Presentational Сomponents** - компоненты отвечающие за внешний вид, они сконцентрированы на том как элемент будет выглядеть. **Сontainer Сomponents** - отвечают за то, как компонент работает, его взаимодействие с api, хранилищем, за  доставку данных к дочерним компонентам. **Presentational Components** часто содержат в себе разметку и стили, редко имеют свой state(если он есть, то он описывает состояние ui элементов, а не данные) и получают(отправляют) данные чз props(чз callback-и полученные из props). **Container Components** наоборот, содержат мало разметки(только оборачивающие div-ы и тп), работают со стейтом, подключены к хранилищу.<br /> 
Такое разделение повышает возможность переиспользования. Так Presentational Components, отделенные от получения данных чз api например, могут быть использованы в другом контейнере, получая данные уже из store. Также такие компоненты представления могут быть вновь использованы в более крупных presentational components - лэйатуах.<br /> 
Однако, этот подход усложняет архитектуру. Появляется новой слой, через который иногда приходится прокидывать props.

#### Q4: Как устроено наследование в JS? Расскажите о своем опыте реализации JSнаследования без использования фреймворков.

В JS используется прототипная модель наследования. Объекты можно связывать в цепочки с помощью свойства ```__proto__```. Так, если в объекте нет нужного свойства, оно ищется в объекте на который ссылается ```__proto__```(в прототипе). Если свойство не найдется и там, то поиск продолжится в ```__proto__``` прототипа и так далее.<br />
В JS есть метод ```Object.create(proto, [properties])``` который возвращает объект с указанным прототипом. Второй аргумент является необязательным и позволяет устанавливать дескрипторы свойств.<br />
Также в JS любая функция  может выступить в роли конструктора. Для этого нужно вызвать ее с ключевым словом ```new```:
```javascript
function MyFunc() {};
new MyFunc();
```
Конструкторы принято называть с большой буквы. При вызове функции чз ```new```, изначально контекст функции будет ссылаться на пустой объект. В теле функции мы, имея доступ к нему через ```this```, можем записывать в этот объект свойства и методы. После выполнения функция возвратит этот объект. Это поведение можно изменить явно вернув какой-либо объект чз ```return someObj;```. Но если ```return``` не вызывается или вызывается с примитивом, то возвращен будет тот самый ```this```.<br />
Мы можем задать функции специальное свойство ```prototype```. При использовании ф-ии в качестве конструктора, она запишет в ```__proto__``` возвращаемого объекта значение из ```prototype```. В prototype конструктора обычно кладутся публичные методы, которые потом будут вызываться на экземплярах. У каждой ф-ии по умолчанию уже есть ```prototype``` содержащий ссылку на саму функцию под ключом ```constructor```:
```javascript
function myFunc() {};

myFunc.prototype.constructor === myFunc; // true
```
Для наследования методов одного конструктора в другом мы должны положить в prototype потомка объект имеющий доступ к публичным методам родителя. Делается это с помощью ```Object.create```:
```javascript
function Parent(options) {
  this.name =  options.name;
}

Parent.prototype.sayHi = function() {
  alert(`Hi my name is ${this.name}`);
}

function Child(options) {
  // вызываем родительский конструктор
  Parent.apply(this, arguments);
}

// наследуем методы
Child.prototype = Object.create(Parent.prototype)
Child.prototype.constructor = Child; // не теряя при этом constructor

// добавляем свои методы, не перезаписывая prototype родителя т.к.
// использовали Object.create

Child.prototype.sayBye = function() {
  alert(`Best wishes. With love yours ${this.name}`);
}
```
Стоит отметить, что в современном стандарте появились классы, которые реализуют наследование внешне более похожее на классический ООП стиль, но являются лишь синтаксическим сахаром, используя все те же прототипы внутри:
```javascript
class Parent {
  constructor(options) {
    this.name = options.name;
  }
  
  sayHi() {
    alert(`Hi my name is ${this.name}`);
  }
}

class Child extends Parent {
  constructor(options) {
    super(options);
  }

  sayBye() {
    alert(`Best wishes. With love yours ${this.name}`);
  }
}
```

Я использовал наследование для реализации графиков с помощью библиотеки Chart.js. В рамках этой задачи я создал свой конструктор наследованный от конструктора Chart.js, добавил в него некоторые дефолтные опции и новые методы, получив более удобный интерфейс для создания графиков нужных именно нам. Еще я использовал наследование с библиотекой Split.js, для расширения функционала, чтобы была возможность сохранения размеров сплиттера в localStorage. Изначально я реализовывал это наследование на прототипах, после подключения webpacker переписал на классы.

#### Q5: Какие библиотеки можно использовать для написания тестов end-to-end во фронтенде? Расскажите о своем опыте тестирования веб-приложений.

Cypress - относительно новый инструмент для end-to-end тестов. Также, насколько я знаю, используют Sinon. У меня нет опыта написания end-to-end тестов, но я писал unit тесты в ходе работы над тестовым заданием. Также я писал тесты для нашего внутреннего npm пакета с помощью mocha. Помимо этого использовал rspec для unit тестов когда писал серверную часть на текущем месте работы.  

#### Q6: Вам нужно реализовать форму для отправки данных на сервер, состоящую из нескольких шагов. В вашем распоряжении дизайн формы и статичная верстка, в которой не показано, как форма должна работать в динамике. Подробного описания, как должны вести себя различные поля в зависимости от действий пользователя, в требованиях к проекту нет. Ваши действия?

 Зависит от проекта. Сейчас я работаю на внутреннем проекте, роль дизайнеров у нас выполняют аналитики и зачастую я сам предлагаю интерфейсные решения. Если вижу что можно что-либо улучшить или просто подробного требования нет, то предлагаю свой вариант, согласовываю с автором задачи и реализую.<br />
В общем случае, я бы обсудил требования с менеджером и дизайнером, предложив свои варианты, и воплотил принятое решение в жизнь.

#### Q7: Расскажите, какие инструменты помогают вам экономить время в процессе написания, проверки и отладки кода.

В последнее время я использую VScode в качестве основного редактора. Через нее можно дебажить node.js приложения, есть полезные плагины, например Jest для работы с тестами. Помогает автокомплит и навигация по названию функции к ее телу. Клиентскую часть я дебажу через консоль Chrome.<br />
Также использую возможности OS(в основном сижу на linux mint). Я подстроил под себя hot keys для быстрого переключения му рабочими столами, запуска терминала и пр. Добавил пару alias для быстрого перехода в рабочую директорию и подключению к вводу в docker контейнер, чтобы использовать binding на бэкенде(команда docker attach). Пользуюсь командой grep. Чаще всего для быстрого поиска нужных rails роутов. На рабочем компе стоит zsh. Не скажу, что использую все возможности этой оболочки на 100%, но работа с git упрощается.<br />
Еще я написал небольшой скрипт для добавления svg иконок в проект. Он прогоняет иконку через svgo оптимизатор и добавляет миксин с этой иконкой в качестве бэкграунда. Правда сейчас таким способом иконки мы подключаем редко, но я думаю этот скрипт сэкономил мне какое-то количество времени. Выглядит он так: https://github.com/EgorOvechkin/my-helpers-scripts/blob/master/import_to_crm.sh

#### Q8:Какие ресурсы вы используете для развития в профессиональной сфере? Приведите несколько конкретных примеров (сайты, блоги и так далее). Какие ещё области знаний, кроме тех, что непосредственно относятся к работе, вам интересны?

Читаю статьи на https://medium.com/, https://www.smashingmagazine.com/, https://habr.com/ru/ . За справочной информацией часто хожу на https://developer.mozilla.org. Перечитываю http://learn.javascript.ru/ . Часто на этих ресурсах есть ссылки на спецификации, бывает перехожу по ним, читаю первоисточник. Люблю решать задачки на codewars: https://www.codewars.com/users/EgorOvechkin/completed_solutions.<br />
Интересуюсь шахматами в последнее время. Играю редко, больше смотрю разборы партий. Интересно все, что связанно с IT, даже за пределами веба.  

#### Q9: Расскажите нам немного о себе и предоставьте несколько ссылок на последние работы, выполненные вами.

Пишу на JavaScript около 3,5 лет. Работал с React, NodeJS, MongoDB, Backbone, Ruby on Rails. Сейчас ищу команду в которой я бы мог решать интересные задачи с помощью  современных технологий.<br />
Вне работы люблю почитать художественную литературу, чаще зарубежную. Сам пробовал немного писать стихи и рассказы. Провожу время с семьёй, у меня есть дочь. Участвую в конкурсах по программированию, прохожу курсы, решаю задачки.<br />
Серьёзных pet-projects у меня нет, но можно посмотреть на следующие мои репозитории:<br />
https://github.com/EgorOvechkin/users_api - тестовое задание на должность Node.js разработчика. API для работы с профилями пользователей.<br />
https://github.com/EgorOvechkin/scroll_drawing - html страница с svg, отрисовывающимся при скролле.<br />
https://github.com/EgorOvechkin/action_cable_chart_room - простая чат комната в рамках изучения функционала Rails Action Cabel.<br />
